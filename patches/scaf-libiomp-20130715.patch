diff --git a/kmp.h b/kmp.h
index 1fb20f9..0299fb7 100644
--- a/kmp.h
+++ b/kmp.h
@@ -275,7 +275,8 @@ enum dynamic_mode {
 #endif /* USE_LOAD_BALANCE */
     dynamic_random,
     dynamic_thread_limit,
-    dynamic_max
+    dynamic_max,
+    dynamic_scaf
 };
 
 /* external schedule constants, duplicate enum omp_sched in omp.h in order to not include it here */
diff --git a/kmp_csupport.c b/kmp_csupport.c
index 8f86d8d..733c046 100644
--- a/kmp_csupport.c
+++ b/kmp_csupport.c
@@ -49,6 +49,12 @@
 #include "kmp_i18n.h"
 #include "kmp_error.h"
 
+extern "C"
+{
+#include <scaf.h>
+}
+extern int scaf_last_allocation;
+
 #define MAX_MESSAGE 512
 
 /* ------------------------------------------------------------------------ */
@@ -310,6 +316,56 @@ __kmpc_fork_call(ident_t *loc, kmp_int32 argc, kmpc_micro microtask, ...)
     va_list     ap;
     va_start(   ap, microtask );
 
+    //SCAF: set up an ad-hoc structure to convert our functor to accept a
+    //single void pointer argument
+    struct squishedargs {
+      int argc;
+      void **args;
+      microtask_t microtask;
+      int gtid;
+      ident_t *loc;
+    };
+
+    //SCAF: collect arguments for the section/task itself
+    void* args[argc];
+    {
+       va_list ap_l;
+       va_start(ap_l, microtask);
+       void** argv = args;
+       int i;
+       for( i=argc-1; i >= 0; --i )
+          *argv++ = va_arg( ap_l, void * );
+    }
+
+    //SCAF: store all arguments for the functor into a single blob
+    struct squishedargs funcdata;
+    funcdata.argc = argc;
+    funcdata.args = args;
+    funcdata.microtask = microtask;
+    funcdata.gtid = gtid;
+    funcdata.loc = loc;
+
+    //SCAF: now describe a functor for passing to libscaf, which will
+    //eventually run the serialized section as local::serialexecute(&funcdata).
+    //Note that the entire experimental process will always just stop after
+    //this runs, so we needn't make any attempt to clean up afterward.
+    struct local
+    {
+       static void serialexecute(void *data){
+          struct squishedargs *fd = (struct squishedargs*)data;
+          __kmpc_serialized_parallel(fd->loc, fd->gtid);
+          __kmp_invoke_microtask(fd->microtask, fd->gtid, 0, fd->argc, fd->args);
+       }
+    };
+
+    //SCAF: Just to be clear, collect our usual fn, data pair.
+    void (*fn) (void*) = local::serialexecute;
+    void *data = &funcdata;
+
+    //SCAF: Re-using the GOMP port's create function, launch the experiment.
+    scaf_last_allocation = scaf_section_start((void*)microtask);
+    scaf_gomp_training_create(fn, data);
+
     __kmp_fork_call( loc, gtid, TRUE,
             argc,
             VOLATILE_CAST(microtask_t) microtask,
@@ -323,6 +379,9 @@ __kmpc_fork_call(ident_t *loc, kmp_int32 argc, kmpc_micro microtask, ...)
             );
     __kmp_join_call( loc, gtid );
 
+    scaf_section_end();
+    scaf_gomp_training_destroy();
+
     va_end( ap );
   }
 }
diff --git a/kmp_runtime.c b/kmp_runtime.c
index 8290d9b..1f97560 100644
--- a/kmp_runtime.c
+++ b/kmp_runtime.c
@@ -54,6 +54,12 @@
 #include "kmp_io.h"
 #include "kmp_error.h"
 
+extern "C"
+{
+#include <scaf.h>
+}
+int scaf_last_allocation = 0;
+
 /* these are temporary issues to be dealt with */
 #define KMP_USE_PRCTL 0
 #define KMP_USE_POOLED_ALLOC 0
@@ -2068,7 +2074,7 @@ __kmp_end_split_barrier( enum barrier_type bt, int gtid )
  */
 static int
 __kmp_reserve_threads( kmp_root_t *root, kmp_team_t *parent_team,
-   int master_tid, int set_nthreads
+   int master_tid, int set_nthreads, microtask_t microtask
 )
 {
     int capacity;
@@ -2146,6 +2152,9 @@ __kmp_reserve_threads( kmp_root_t *root, kmp_team_t *parent_team,
             }
         }
     }
+    else if ( __kmp_global.g.g_dynamic_mode == dynamic_scaf ) {
+       new_nthreads = scaf_last_allocation;
+    }
     else {
         KMP_ASSERT( 0 );
     }
@@ -2390,7 +2399,7 @@ __kmp_fork_call(
     {
         nthreads = master_set_numthreads ?
             master_set_numthreads : get__nproc_2( parent_team, master_tid );
-        nthreads = __kmp_reserve_threads( root, parent_team, master_tid, nthreads
+        nthreads = __kmp_reserve_threads( root, parent_team, master_tid, nthreads, microtask
         );
     }
     KMP_DEBUG_ASSERT( nthreads > 0 );
diff --git a/kmp_settings.c b/kmp_settings.c
index 0bb23e7..1b50c18 100644
--- a/kmp_settings.c
+++ b/kmp_settings.c
@@ -3302,6 +3302,9 @@ __kmp_stg_parse_kmp_dynamic_mode( char const * name, char const * value, void *
     else if ( __kmp_str_match( "random", 1, value ) ) {
         __kmp_global.g.g_dynamic_mode = dynamic_random;
     }
+    else if ( __kmp_str_match( "scaf", 0, value ) ) {
+        __kmp_global.g.g_dynamic_mode = dynamic_scaf;
+    }
     else {
         KMP_WARNING( StgInvalidValue, name, value );
     }
